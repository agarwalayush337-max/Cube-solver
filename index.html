<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Video Replica Solver</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cubejs@1.3.2/lib/cube.min.js"></script>

    <style>
        /* --- 1. EXACT VIDEO LAYOUT STYLES --- */
        body { margin: 0; background: #000; height: 100vh; display: flex; flex-direction: column; overflow: hidden; font-family: sans-serif; }
        
        /* Top Half: Camera */
        #camera-container {
            flex: 60; position: relative; overflow: hidden; background: #000;
        }
        #video-feed {
            width: 100%; height: 100%; object-fit: cover;
            transform: scaleX(1); /* No Mirroring for Rear Camera */
        }
        
        /* The Green Grid from the video */
        #scan-grid {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 260px; height: 260px;
            display: grid; grid-template-columns: repeat(3, 1fr);
            border: 4px solid #00FF00;
            box-shadow: 0 0 15px #00FF00;
            z-index: 10;
        }
        .grid-cell { border: 1px solid rgba(0, 255, 0, 0.3); position: relative; }
        
        /* The "Dot" that shows detected color */
        .color-dot {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 12px; height: 12px; border-radius: 50%;
            border: 1px solid white; box-shadow: 0 0 4px black;
            background: transparent;
        }

        /* Scan Status Pill */
        #status-pill {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.7); color: white; padding: 8px 16px; border-radius: 20px;
            font-weight: bold; border: 1px solid #444; pointer-events: none;
        }

        /* Bottom Half: 3D Cube & Controls */
        #controls-container {
            flex: 40; background: #111; display: flex; flex-direction: column;
            border-top: 2px solid #333;
        }
        
        #three-view { flex: 1; width: 100%; position: relative; }
        
        /* Face Selector Bar */
        #face-bar {
            display: flex; justify-content: space-around; padding: 10px; background: #000;
        }
        .face-btn {
            background: none; border: none; color: #555; font-weight: 900; font-size: 14px; padding: 10px;
        }
        .face-btn.active { color: #00FF00; border-bottom: 2px solid #00FF00; }
        .face-btn.done { color: white; }

        /* Main Button */
        #action-btn {
            width: 90%; margin: 10px auto; padding: 15px; border: none; border-radius: 8px;
            background: white; font-weight: 800; font-size: 18px; text-transform: uppercase;
        }
        #solve-btn { display: none; background: #007AFF; color: white; width: 90%; margin: 10px auto; padding: 15px; border: none; border-radius: 8px; font-weight: 800; font-size: 18px; }

    </style>
</head>
<body>

    <div id="camera-container">
        <video id="video-feed" autoplay playsinline muted></video>
        <div id="status-pill">Align Center: WHITE</div>
        
        <div id="scan-grid">
            <div class="grid-cell"><div class="color-dot" id="d0"></div></div>
            <div class="grid-cell"><div class="color-dot" id="d1"></div></div>
            <div class="grid-cell"><div class="color-dot" id="d2"></div></div>
            <div class="grid-cell"><div class="color-dot" id="d3"></div></div>
            <div class="grid-cell"><div class="color-dot" id="d4"></div></div>
            <div class="grid-cell"><div class="color-dot" id="d5"></div></div>
            <div class="grid-cell"><div class="color-dot" id="d6"></div></div>
            <div class="grid-cell"><div class="color-dot" id="d7"></div></div>
            <div class="grid-cell"><div class="color-dot" id="d8"></div></div>
        </div>
        <canvas id="cv-canvas" style="display:none"></canvas>
    </div>

    <div id="controls-container">
        <div id="three-view"></div>
        
        <div id="face-bar">
            <button class="face-btn active" onclick="setFace('U')">UP</button>
            <button class="face-btn" onclick="setFace('L')">LT</button>
            <button class="face-btn" onclick="setFace('F')">FR</button>
            <button class="face-btn" onclick="setFace('R')">RT</button>
            <button class="face-btn" onclick="setFace('B')">BK</button>
            <button class="face-btn" onclick="setFace('D')">DN</button>
        </div>

        <button id="action-btn" onclick="capture()">CAPTURE</button>
        <button id="solve-btn" onclick="solve()">SOLVE CUBE</button>
    </div>

    <script>
        // --- CONFIGURATION ---
        const COLORS = {
            'U': '#FFFFFF', 'R': '#B90000', 'F': '#009E60',
            'D': '#FFD500', 'L': '#FF5800', 'B': '#0045AD'
        };
        const FACE_ORDER = ['U', 'L', 'F', 'R', 'B', 'D']; // Scan flow
        let currentFace = 'U';
        let cubeState = { 'U':[], 'L':[], 'F':[], 'R':[], 'B':[], 'D':[] };
        let liveColors = Array(9).fill('U');

        // THREE.JS VARS
        let scene, camera, renderer, cubeGroup;
        let faceMaterials = {}; // Stores references to the 54 materials for instant updates

        // --- 1. STARTUP ---
        window.onload = function() {
            initCamera();
            init3D();
            setFace('U');
            requestAnimationFrame(scanLoop);
        };

        async function initCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } }
                });
                const video = document.getElementById('video-feed');
                video.srcObject = stream;
                video.play();
            } catch (err) { alert("Camera access failed: " + err); }
        }

        // --- 2. THE VISION ENGINE (HSV + Brightness Fix) ---
        function scanLoop() {
            const video = document.getElementById('video-feed');
            const canvas = document.getElementById('cv-canvas');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });

            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                ctx.drawImage(video, 0, 0);

                // Grid Math
                const size = Math.min(canvas.width, canvas.height) * 0.55;
                const startX = (canvas.width - size) / 2;
                const startY = (canvas.height - size) / 2;
                const step = size / 3;

                // Scan 9 points
                for (let i = 0; i < 9; i++) {
                    const r = Math.floor(i / 3);
                    const c = i % 3;
                    const x = startX + c * step + step / 2;
                    const y = startY + r * step + step / 2;

                    const p = ctx.getImageData(x, y, 1, 1).data;
                    const colorCode = detectColor(p[0], p[1], p[2]);
                    
                    liveColors[i] = colorCode;
                    
                    // Update HTML Dots
                    document.getElementById('d'+i).style.backgroundColor = COLORS[colorCode];
                }
                
                // Update 3D Cube immediately
                update3D();
            }
            requestAnimationFrame(scanLoop);
        }

        function detectColor(r, g, b) {
            // Convert to HSV
            let rr=r/255, gg=g/255, bb=b/255;
            let max=Math.max(rr,gg,bb), min=Math.min(rr,gg,bb);
            let h, s, v=max;
            let d = max - min;
            s = max==0 ? 0 : d/max;
            if(max==min) h=0;
            else {
                switch(max){
                    case rr: h=(gg-bb)/d+(gg<bb?6:0); break;
                    case gg: h=(bb-rr)/d+2; break;
                    case bb: h=(rr-gg)/d+4; break;
                }
                h/=6;
            }

            // --- ROBUST THRESHOLDS ---
            // 1. WHITE (Low Saturation)
            if (s < 0.20 && v > 0.3) return 'U';
            
            // 2. ORANGE vs RED vs YELLOW
            if (v > 0.2) {
                // Yellow is usually bright and around 0.14-0.18
                if (h > 0.12 && h < 0.22) return 'D'; 
                
                // Orange is distinctly around 0.06 - 0.11
                if (h >= 0.06 && h <= 0.12) return 'L';
                
                // Red is at the edges (0.0 - 0.05 OR 0.95 - 1.0)
                if (h < 0.06 || h > 0.90) return 'R';
            }
            
            // 3. GREEN vs BLUE
            if (h > 0.22 && h < 0.48) return 'F'; // Green
            if (h > 0.50 && h < 0.75) return 'B'; // Blue
            
            return 'U'; // Fallback
        }

        // --- 3. 3D SYSTEM (HARDCODED MAPPING) ---
        function init3D() {
            const container = document.getElementById('three-view');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            
            camera = new THREE.PerspectiveCamera(50, container.clientWidth/container.clientHeight, 0.1, 100);
            camera.position.z = 5; 
            
            renderer = new THREE.WebGLRenderer({antialias:true});
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            cubeGroup = new THREE.Group();
            const geometry = new THREE.BoxGeometry(0.95, 0.95, 0.95);

            // Create 27 Cubies
            // We give them IDs to map them to faces later
            let id = 0;
            for(let x=-1; x<=1; x++) {
                for(let y=-1; y<=1; y++) {
                    for(let z=-1; z<=1; z++) {
                        const mats = [];
                        for(let i=0; i<6; i++) {
                            const mat = new THREE.MeshBasicMaterial({color: 0x222222});
                            mats.push(mat);
                            
                            // Store reference based on position and normal
                            // 0:Right, 1:Left, 2:Top, 3:Bottom, 4:Front, 5:Back
                            let key = null;
                            if(i==0 && x==1) key = `R_${9 - (3*(y+1)) - (z+1)}`; // Complex map logic simplified below
                            // ... Mapping algorithmic is error prone.
                            // We will use a direct update in update3D()
                        }
                        const mesh = new THREE.Mesh(geometry, mats);
                        mesh.position.set(x, y, z);
                        mesh.userData = {x,y,z};
                        cubeGroup.add(mesh);
                    }
                }
            }
            scene.add(cubeGroup);
            
            function animate() { requestAnimationFrame(animate); renderer.render(scene, camera); }
            animate();
        }

        // THIS IS THE FIX: Explicitly map the 9 scanned colors to the specific 3D faces
        // No sorting. Just Physics.
        function update3D() {
            // Depending on currentFace, we know EXACTLY which cubies to paint.
            // We filter the group children by x,y,z coordinates.
            
            // 1. Get the 9 meshes for the current face
            let targets = [];
            const kids = cubeGroup.children;
            
            if(currentFace === 'F') { // Front (z=1)
                // Grid 0(TopLeft) is x=-1, y=1. Grid 8(BotRight) is x=1, y=-1
                targets = kids.filter(m => m.userData.z === 1);
                targets.sort((a,b) => (b.userData.y - a.userData.y) || (a.userData.x - b.userData.x));
                paint(targets, 4); // Material 4 is Front
            }
            else if(currentFace === 'B') { // Back (z=-1)
                targets = kids.filter(m => m.userData.z === -1);
                // Back is mirrored horizontally relative to camera usually
                targets.sort((a,b) => (b.userData.y - a.userData.y) || (b.userData.x - a.userData.x));
                paint(targets, 5); // Mat 5 Back
            }
            else if(currentFace === 'U') { // Up (y=1)
                targets = kids.filter(m => m.userData.y === 1);
                targets.sort((a,b) => (a.userData.z - b.userData.z) || (a.userData.x - b.userData.x));
                paint(targets, 2); // Mat 2 Top
            }
            else if(currentFace === 'D') { // Down (y=-1)
                targets = kids.filter(m => m.userData.y === -1);
                targets.sort((a,b) => (b.userData.z - a.userData.z) || (a.userData.x - b.userData.x));
                paint(targets, 3); // Mat 3 Bottom
            }
            else if(currentFace === 'L') { // Left (x=-1)
                targets = kids.filter(m => m.userData.x === -1);
                targets.sort((a,b) => (b.userData.y - a.userData.y) || (a.userData.z - b.userData.z));
                paint(targets, 1); // Mat 1 Left
            }
            else if(currentFace === 'R') { // Right (x=1)
                targets = kids.filter(m => m.userData.x === 1);
                targets.sort((a,b) => (b.userData.y - a.userData.y) || (b.userData.z - a.userData.z));
                paint(targets, 0); // Mat 0 Right
            }
        }
        
        function paint(meshes, matIndex) {
            liveColors.forEach((color, i) => {
                if(meshes[i]) meshes[i].material[matIndex].color.set(COLORS[color]);
            });
        }

        // --- 4. APP CONTROL ---
        function setFace(face) {
            currentFace = face;
            
            // UI
            document.querySelectorAll('.face-btn').forEach(b => b.classList.remove('active'));
            const btn = Array.from(document.querySelectorAll('.face-btn')).find(b => b.innerText.includes(face=='L'?'LT':face=='R'?'RT':face=='F'?'FR':face=='B'?'BK':face=='U'?'UP':'DN'));
            if(btn) btn.classList.add('active');
            
            document.getElementById('status-pill').innerText = `Align Center: ${getFaceName(face)}`;

            // Rotate Cube View
            rotateView(face);
        }
        
        function getFaceName(f) {
            return {'U':'WHITE','F':'GREEN','R':'RED','L':'ORANGE','B':'BLUE','D':'YELLOW'}[f];
        }

        function rotateView(face) {
            cubeGroup.rotation.set(0,0,0);
            if(face==='U') cubeGroup.rotation.x = 0.5;
            if(face==='D') cubeGroup.rotation.x = -0.5;
            if(face==='R') cubeGroup.rotation.y = -0.5; // Slight angle to see depth
            if(face==='L') cubeGroup.rotation.y = 0.5;
            if(face==='B') cubeGroup.rotation.y = 3.14;
        }

        function capture() {
            cubeState[currentFace] = [...liveColors];
            
            // Mark Done
            const btn = document.querySelector('.face-btn.active');
            btn.classList.add('done');
            
            // Next
            const idx = FACE_ORDER.indexOf(currentFace);
            if(idx < 5) {
                setFace(FACE_ORDER[idx+1]);
            } else {
                document.getElementById('action-btn').style.display = 'none';
                document.getElementById('solve-btn').style.display = 'block';
            }
        }
        
        function solve() {
            let str = "";
            ['U','R','F','D','L','B'].forEach(f => str += cubeState[f].join(''));
            
            alert("Calculating Solution for: " + str);
            
            const worker = new Worker('solver-worker.js');
            worker.postMessage(str);
            worker.onmessage = (e) => {
                if(e.data.success) alert("Solution: " + e.data.solution);
                else alert("Error: " + e.data.error);
            }
        }
    </script>
</body>
</html>
