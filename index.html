<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Master Solver</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <style>
        body { margin: 0; background: #111; color: white; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        
        #canvas-container { width: 100vw; height: 65vh; background: #000; position: relative; }
        
        /* UI OVERLAY */
        #ui-layer {
            height: 35vh; background: #1a1a1a; display: flex; flex-direction: column;
            padding: 10px; box-sizing: border-box; border-top: 2px solid #333;
        }

        /* PALETTE */
        #palette {
            display: flex; justify-content: center; gap: 15px; margin-bottom: 15px;
        }
        .color-btn {
            width: 40px; height: 40px; border-radius: 50%; border: 3px solid #333;
            cursor: pointer; transition: transform 0.2s;
        }
        .color-btn.active { transform: scale(1.2); border-color: white; box-shadow: 0 0 10px white; }

        /* CONTROLS */
        #controls-area {
            flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        
        button.action-btn {
            background: white; color: black; border: none; padding: 12px 40px;
            font-size: 18px; font-weight: 800; border-radius: 30px;
            text-transform: uppercase; cursor: pointer;
        }
        
        /* PLAYER (Hidden initially) */
        #player {
            display: none; width: 100%; flex-direction: column; align-items: center;
        }
        #move-display { font-size: 30px; font-family: monospace; color: #00ff00; margin-bottom: 10px; font-weight: bold; }
        
        .transport-btns { display: flex; gap: 20px; margin-bottom: 10px; }
        .t-btn {
            background: #333; color: white; border: 1px solid #555; width: 50px; height: 50px;
            border-radius: 12px; font-size: 20px; cursor: pointer; display: flex; justify-content: center; align-items: center;
        }
        
        /* SLIDER */
        input[type=range] { width: 90%; accent-color: #00ff00; }

        #help-text {
            position: absolute; top: 10px; width: 100%; text-align: center;
            pointer-events: none; text-shadow: 0 2px 4px black; opacity: 0.7;
        }
    </style>
</head>
<body>

    <div id="canvas-container">
        <div id="help-text">Select Color -> Tap Cube to Paint</div>
    </div>

    <div id="ui-layer">
        <div id="palette">
            <div class="color-btn active" style="background:#FFFFFF" onclick="setColor('U')"></div> <div class="color-btn" style="background:#009E60" onclick="setColor('F')"></div> <div class="color-btn" style="background:#B90000" onclick="setColor('R')"></div> <div class="color-btn" style="background:#0045AD" onclick="setColor('B')"></div> <div class="color-btn" style="background:#FF5800" onclick="setColor('L')"></div> <div class="color-btn" style="background:#FFD500" onclick="setColor('D')"></div> </div>

        <div id="controls-area">
            <button id="solve-btn" class="action-btn" onclick="startSolve()">SOLVE</button>
            
            <div id="player">
                <div id="move-display">READY</div>
                <div class="transport-btns">
                    <button class="t-btn" onclick="playPause()" id="play-btn">▶</button>
                    <button class="t-btn" onclick="step(-1)">⏮</button>
                    <button class="t-btn" onclick="step(1)">⏭</button>
                    <button class="t-btn" onclick="resetCube()">↺</button>
                </div>
                <input type="range" id="progress" min="0" max="0" value="0" oninput="scrub(this.value)">
            </div>
        </div>
    </div>

    <script id="worker-code" type="javascript/worker">
        importScripts('https://cdn.jsdelivr.net/npm/cubejs@1.3.2/lib/cube.min.js');
        self.onmessage = function(e) {
            Cube.initSolver();
            const solver = new Cube();
            try {
                // Input format: UUU...RRR...FFF...DDD...LLL...BBB
                const sol = solver.solve(Cube.fromString(e.data));
                self.postMessage({success: true, solution: sol});
            } catch(err) {
                self.postMessage({success: false, error: "Invalid Cube State"});
            }
        };
    </script>

    <script>
        // --- 1. CONFIGURATION ---
        const COLORS = {
            'U': 0xFFFFFF, 'F': 0x009E60, 'R': 0xB90000,
            'B': 0x0045AD, 'L': 0xFF5800, 'D': 0xFFD500, 'G': 0x333333 // Grey
        };
        const FACE_MAP = {0:'R', 1:'L', 2:'U', 3:'D', 4:'F', 5:'B'}; // Material Indices

        let selectedColor = 'U';
        let isSolving = false;
        let solution = [];
        let currentStep = 0;
        let isPlaying = false;
        let animationSpeed = 500; // ms per move

        // THREE.JS VARS
        let scene, camera, renderer, controls;
        let cubies = []; // Array of 27 meshes
        let pivot; // For rotation animation

        // --- 2. INITIALIZATION ---
        window.onload = init;

        function init() {
            const container = document.getElementById('canvas-container');
            
            // Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / (window.innerHeight*0.65), 0.1, 100);
            camera.position.set(5, 5, 7);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight * 0.65);
            container.appendChild(renderer.domElement);

            // Controls (Orbit)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enablePan = false;
            controls.enableDamping = true;

            // Build Cube
            buildCube();

            // Raycaster for Clicking
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            renderer.domElement.addEventListener('pointerdown', (event) => {
                if(isSolving) return; // Lock painting during solve
                
                // Calculate mouse position
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(cubies);

                if (intersects.length > 0) {
                    controls.enabled = false; // Disable rotation while painting
                    const hit = intersects[0];
                    const mesh = hit.object;
                    const materialIndex = hit.face.materialIndex;
                    
                    // Apply Color
                    mesh.material[materialIndex].color.setHex(COLORS[selectedColor]);
                    
                    // Store logical color in userData for solver
                    mesh.userData.faceColors[materialIndex] = selectedColor;
                }
            });

            renderer.domElement.addEventListener('pointerup', () => controls.enabled = true);

            // Loop
            animate();
        }

        function buildCube() {
            const geo = new THREE.BoxGeometry(0.95, 0.95, 0.95);
            pivot = new THREE.Object3D(); // Helper for rotations
            scene.add(pivot);

            for(let x=-1; x<=1; x++) {
                for(let y=-1; y<=1; y++) {
                    for(let z=-1; z<=1; z++) {
                        // Default to Grey, we will paint "solved" state initially
                        const mats = Array(6).fill(null).map(() => new THREE.MeshBasicMaterial({color: COLORS['G']}));
                        const mesh = new THREE.Mesh(geo, mats);
                        mesh.position.set(x, y, z);
                        
                        // Logical Data
                        mesh.userData = { 
                            startPos: new THREE.Vector3(x,y,z), // To track position
                            faceColors: {0:'G',1:'G',2:'G',3:'G',4:'G',5:'G'} 
                        };

                        // Pre-paint a solved cube for convenience? 
                        // User asked to "Manually fill". So we leave it grey or pre-fill solved?
                        // Let's pre-fill Solved so they just have to change the scrambled parts.
                        paintSticker(mesh, x, y, z);

                        cubies.push(mesh);
                        scene.add(mesh);
                    }
                }
            }
        }

        function paintSticker(mesh, x, y, z) {
            // Helper to paint default solved state
            if(x===1) { mesh.material[0].color.setHex(COLORS['R']); mesh.userData.faceColors[0] = 'R'; }
            if(x===-1){ mesh.material[1].color.setHex(COLORS['L']); mesh.userData.faceColors[1] = 'L'; }
            if(y===1) { mesh.material[2].color.setHex(COLORS['U']); mesh.userData.faceColors[2] = 'U'; }
            if(y===-1){ mesh.material[3].color.setHex(COLORS['D']); mesh.userData.faceColors[3] = 'D'; }
            if(z===1) { mesh.material[4].color.setHex(COLORS['F']); mesh.userData.faceColors[4] = 'F'; }
            if(z===-1){ mesh.material[5].color.setHex(COLORS['B']); mesh.userData.faceColors[5] = 'B'; }
        }

        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time);
            controls.update();
            renderer.render(scene, camera);
        }

        // --- 3. UI LOGIC ---
        function setColor(c) {
            selectedColor = c;
            // Update UI Highlight
            document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
            const btn = Array.from(document.querySelectorAll('.color-btn')).find(b => b.style.background.includes(getColorHexStr(c)));
            // Simple visual hack for selection
            event.target.classList.add('active');
        }
        
        function getColorHexStr(c) {
            if(c==='U') return '255, 255, 255'; // White
            if(c==='R') return '185, 0, 0';
            // ... simple check, or just rely on click event
            return '';
        }

        // --- 4. SOLVER LOGIC ---
        function startSolve() {
            // 1. Read State from 3D Meshes
            // We need to construct the string: U... R... F... D... L... B...
            // Scan positions based on World Coordinates
            
            const getFaceStr = (face) => {
                // Filter cubies based on world position
                let faceCubies = [];
                // Sort order is crucial: Top-Left to Bottom-Right
                
                if(face==='U') {
                    faceCubies = cubies.filter(m => Math.abs(m.position.y - 1) < 0.1);
                    faceCubies.sort((a,b) => (a.position.z - b.position.z) || (a.position.x - b.position.x));
                    return faceCubies.map(m => m.userData.faceColors[2]).join('');
                }
                if(face==='D') {
                    faceCubies = cubies.filter(m => Math.abs(m.position.y + 1) < 0.1);
                    faceCubies.sort((a,b) => (b.position.z - a.position.z) || (a.position.x - b.position.x));
                    return faceCubies.map(m => m.userData.faceColors[3]).join('');
                }
                if(face==='F') {
                    faceCubies = cubies.filter(m => Math.abs(m.position.z - 1) < 0.1);
                    faceCubies.sort((a,b) => (b.position.y - a.position.y) || (a.position.x - b.position.x));
                    return faceCubies.map(m => m.userData.faceColors[4]).join('');
                }
                if(face==='B') {
                    faceCubies = cubies.filter(m => Math.abs(m.position.z + 1) < 0.1);
                    faceCubies.sort((a,b) => (b.position.y - a.position.y) || (b.position.x - a.position.x));
                    return faceCubies.map(m => m.userData.faceColors[5]).join('');
                }
                if(face==='L') {
                    faceCubies = cubies.filter(m => Math.abs(m.position.x + 1) < 0.1);
                    faceCubies.sort((a,b) => (b.position.y - a.position.y) || (a.position.z - b.position.z));
                    return faceCubies.map(m => m.userData.faceColors[1]).join('');
                }
                if(face==='R') {
                    faceCubies = cubies.filter(m => Math.abs(m.position.x - 1) < 0.1);
                    faceCubies.sort((a,b) => (b.position.y - a.position.y) || (b.position.z - a.position.z));
                    return faceCubies.map(m => m.userData.faceColors[0]).join('');
                }
            };

            const state = getFaceStr('U') + getFaceStr('R') + getFaceStr('F') + getFaceStr('D') + getFaceStr('L') + getFaceStr('B');
            
            // Check for Grey (Unpainted)
            if(state.includes('G')) { alert("Please paint the whole cube first!"); return; }

            console.log("Solving State:", state);

            // 2. Call Worker
            const blob = new Blob([document.querySelector('#worker-code').textContent], { type: "text/javascript" });
            const worker = new Worker(window.URL.createObjectURL(blob));
            
            worker.postMessage(state);
            worker.onmessage = (e) => {
                if(e.data.success) {
                    // Normalize solution string
                    let moves = e.data.solution.trim();
                    // Fix double spaces or empty strings
                    if(moves === "") { alert("Cube is already solved!"); return; }
                    
                    // Parse moves into array (handles '2' and "'" modifiers)
                    // Kociemba output is usually space separated: R U2 D'
                    solution = moves.split(/\s+/);
                    
                    // Setup Player
                    isSolving = true;
                    document.getElementById('solve-btn').style.display = 'none';
                    document.getElementById('palette').style.display = 'none';
                    document.getElementById('player').style.display = 'flex';
                    document.getElementById('progress').max = solution.length;
                    
                    currentStep = 0;
                    updateUI();
                } else {
                    alert("Invalid Cube Configuration! Check your colors.");
                }
            };
        }

        // --- 5. ANIMATION ENGINE (THE "GOOD MODEL" PART) ---
        
        function rotateFace(move, duration = 300) {
            return new Promise(resolve => {
                const face = move[0];
                const modifier = move[1] || '';
                const isPrime = modifier === "'";
                const isDouble = modifier === '2';
                
                let angle = Math.PI / 2 * (isPrime ? 1 : -1);
                if(isDouble) angle *= 2;

                // 1. Group Cubies
                let axis = new THREE.Vector3();
                let group = [];
                
                if(face === 'U') { axis.set(0,1,0); group = cubies.filter(c => c.position.y > 0.5); }
                if(face === 'D') { axis.set(0,1,0); group = cubies.filter(c => c.position.y < -0.5); }
                if(face === 'F') { axis.set(0,0,1); group = cubies.filter(c => c.position.z > 0.5); }
                if(face === 'B') { axis.set(0,0,1); group = cubies.filter(c => c.position.z < -0.5); }
                if(face === 'R') { axis.set(1,0,0); group = cubies.filter(c => c.position.x > 0.5); }
                if(face === 'L') { axis.set(1,0,0); group = cubies.filter(c => c.position.x < -0.5); }

                // 2. Attach to Pivot
                pivot.rotation.set(0,0,0);
                pivot.position.set(0,0,0);
                
                group.forEach(c => {
                    pivot.attach(c); // Three.js 'attach' maintains world transform
                });

                // 3. Tween Rotation
                new TWEEN.Tween(pivot.rotation)
                    .to({ [axis.x ? 'x' : axis.y ? 'y' : 'z']: pivot.rotation[axis.x ? 'x' : axis.y ? 'y' : 'z'] + angle }, duration)
                    .easing(TWEEN.Easing.Quadratic.InOut)
                    .onComplete(() => {
                        // 4. Detach (Bake transforms)
                        group.forEach(c => scene.attach(c));
                        pivot.rotation.set(0,0,0);
                        
                        // Round positions to fix floating point drift
                        group.forEach(c => {
                            c.position.x = Math.round(c.position.x);
                            c.position.y = Math.round(c.position.y);
                            c.position.z = Math.round(c.position.z);
                            c.updateMatrixWorld();
                        });
                        resolve();
                    })
                    .start();
            });
        }

        // --- 6. PLAYBACK CONTROLS ---
        
        async function playPause() {
            isPlaying = !isPlaying;
            document.getElementById('play-btn').innerText = isPlaying ? "⏸" : "▶";
            
            if(isPlaying) {
                while(currentStep < solution.length && isPlaying) {
                    updateUI();
                    await rotateFace(solution[currentStep], animationSpeed);
                    currentStep++;
                    document.getElementById('progress').value = currentStep;
                }
                if(currentStep >= solution.length) isPlaying = false;
                document.getElementById('play-btn').innerText = "▶";
            }
        }

        async function step(dir) {
            if(isPlaying) return; // Block step while playing
            
            if(dir === 1 && currentStep < solution.length) {
                await rotateFace(solution[currentStep], 200);
                currentStep++;
            } 
            else if(dir === -1 && currentStep > 0) {
                currentStep--;
                // Reverse Move logic
                let move = solution[currentStep];
                let rev = move.includes("'") ? move[0] : (move.includes("2") ? move : move[0] + "'");
                await rotateFace(rev, 200);
            }
            updateUI();
            document.getElementById('progress').value = currentStep;
        }

        function updateUI() {
            if(currentStep < solution.length) {
                document.getElementById('move-display').innerText = "Move: " + solution[currentStep];
            } else {
                document.getElementById('move-display').innerText = "SOLVED!";
            }
        }

        function scrub(val) {
            // Complex to implement scrubbing because moves depend on state.
            // For now, simple step is safer. Reset if scrub back to 0.
            if(val == 0 && currentStep > 0) resetCube();
        }

        function resetCube() {
            location.reload();
        }

    </script>
</body>
</html>
